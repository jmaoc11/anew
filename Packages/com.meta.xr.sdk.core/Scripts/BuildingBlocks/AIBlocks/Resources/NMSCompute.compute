/*
* Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * Licensed under the Oculus SDK License Agreement (the "License");
 * you may not use the Oculus SDK except in compliance with the License,
 * which is provided at the time of installation or download, or which
 * otherwise accompanies this software in either electronic or hard copy form.
 *
 * You may obtain a copy of the License at
 *
 * https://developer.oculus.com/licenses/oculussdk/
 *
 * Unless required by applicable law or agreed to in writing, the Oculus SDK
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma kernel CSMain

StructuredBuffer<float4> boxes;
StructuredBuffer<float> scores;
StructuredBuffer<int> classIds;

RWStructuredBuffer<int> keep;
RWStructuredBuffer<int> keptIndices;
RWStructuredBuffer<uint> keptCount;

struct Detection {
  float4 box;
  float score;
  int id;
  float2 pad; // keep 32-byte alignment
};

RWStructuredBuffer<Detection> outDetections;

int numBoxes;
float iouThreshold;
float minConfidence;
int maxKeep;
float scaleX;
float scaleY;

#define THREADS 64

float IoU(float4 a, float4 b) {
  float2 aMin = a.xy - a.zw * 0.5;
  float2 aMax = a.xy + a.zw * 0.5;
  float2 bMin = b.xy - b.zw * 0.5;
  float2 bMax = b.xy + b.zw * 0.5;

  float2 interMin = max(aMin, bMin);
  float2 interMax = min(aMax, bMax);
  float2 interSize = max(interMax - interMin, 0);

  float interArea = interSize.x * interSize.y;
  float areaA = a.z * a.w;
  float areaB = b.z * b.w;

  return interArea / (areaA + areaB - interArea + 1e-6);
}

bool Overlaps(float4 a, float4 b) {
  float2 aMin = a.xy - a.zw * 0.5;
  float2 aMax = a.xy + a.zw * 0.5;
  float2 bMin = b.xy - b.zw * 0.5;
  float2 bMax = b.xy + b.zw * 0.5;

  return !(aMax.x < bMin.x || bMax.x < aMin.x || aMax.y < bMin.y || bMax.y < aMin.y);
}

groupshared float4 gsTileBoxes[THREADS];
groupshared float gsTileScores[THREADS];
groupshared uint gsLaneKeep[THREADS];
groupshared uint gsGroupBase;
groupshared uint gsGroupCount;

[numthreads(THREADS, 1, 1)]
void CSMain(uint3 tid : SV_DispatchThreadID, uint gi : SV_GroupIndex) {
  int gid = tid.x;

  bool inRange = (gid < numBoxes);

  float4 b1 = 0;
  float s1 = -1e9;

  if (inRange) {
    b1 = boxes[gid];
    s1 = scores[gid];
  }

  // No early return: track activity & keepFlag
  bool active = inRange && (s1 >= minConfidence);
  int keepFlag = active ? 1 : 0;

  // Tiled compares â€” all lanes execute loop & barriers
  for (int baseIdx = 0; baseIdx < numBoxes; baseIdx += THREADS) {
    int j = baseIdx + (int)gi;
    gsTileBoxes[gi] = (j < numBoxes) ? boxes[j] : 0;
    gsTileScores[gi] = (j < numBoxes) ? scores[j] : -1e9;

    GroupMemoryBarrierWithGroupSync();

    if (active && keepFlag == 1) {
      [unroll]
      for (int k = 0; k < THREADS; k++) {
        int idx = baseIdx + k;
        if (idx == gid || idx >= numBoxes)
          continue;

        float s2 = gsTileScores[k];
        if (s2 <= s1)
          continue;

        float4 b2 = gsTileBoxes[k];
        if (!Overlaps(b1, b2))
          continue;

        if (IoU(b1, b2) > iouThreshold) {
          keepFlag = 0; // suppressed
          break; // exit inner k-loop only
        }
      }
    }

    GroupMemoryBarrierWithGroupSync();
  }

  // Write keep flag for debug/compat
  if (inRange)
    keep[gid] = (active && keepFlag == 1) ? 1 : 0;

  // Build per-lane flag: only active & kept lanes contribute.
  gsLaneKeep[gi] = (active && keepFlag == 1) ? 1u : 0u;
  GroupMemoryBarrierWithGroupSync();

  // Inclusive scan to get per-lane prefix
  [unroll] for (uint off = 1u; off < THREADS; off <<= 1u) {
    uint add = (gi >= off) ? gsLaneKeep[gi - off] : 0u;
    GroupMemoryBarrierWithGroupSync();
    uint cur = gsLaneKeep[gi];
    gsLaneKeep[gi] = cur + add;
    GroupMemoryBarrierWithGroupSync();
  }

  if (gi == THREADS - 1u)
    gsGroupCount = gsLaneKeep[gi];
  GroupMemoryBarrierWithGroupSync();

  if (gi == 0u) {
    uint baseOut = 0u;
    if (gsGroupCount > 0u)
      InterlockedAdd(keptCount[0], gsGroupCount, baseOut);
    gsGroupBase = baseOut;
  }
  GroupMemoryBarrierWithGroupSync();

  // Write compact detection (only active & kept)
  if (active && keepFlag == 1) {
    uint idxInGroup = gsLaneKeep[gi] - 1u; // 0-based
    uint outIdx = gsGroupBase + idxInGroup;
    if (outIdx < (uint)maxKeep) {
      keptIndices[outIdx] = gid;

      Detection d;
      d.box = float4(b1.x * scaleX, b1.y * scaleY, b1.z * scaleX, b1.w * scaleY);
      d.score = s1;
      d.id = classIds[gid];
      d.pad = 0;
      outDetections[outIdx] = d;
    }
  }
}
